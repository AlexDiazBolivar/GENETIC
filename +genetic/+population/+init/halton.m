function x = halton(popSize, xMin, xMax, xDim)
x           = zeros(xDim,popSize);
seed        = zeros(1, xDim);
leap        = ones(1, xDim);
%
maxPrime    = 1600;
job         = genetic.population.init.prime(1:maxPrime);
primeBase   = job(1:xDim);
%
for j = 1:popSize
   x(:,j) = seqHalton(xDim,j,seed,leap,primeBase)';
end
% Points dispatching within [xMin;xMax]
x = genetic.population.init.dispatchIndividuals(popSize, xMin, xMax, x);
end

function x = seqHalton(dim, step, seed, leap, base)

%
% >> 'seqHalton.m' computes  an element of  a leaped low discrepancy Halton
% >> sequence. The DIM-dimensional  Halton sequence is really  DIM separate
% >> sequences, each generated by a particular  base. This routine  selects
% >> elements of  a "leaped"  subsequence  of the Halton sequence. The sub-
% >> -sequence elements are indexed by a quantity called STEP, which starts
% >> at 0. The STEP-th subsequence element is simply element:
%
% >> SEED(1:DIM) + STEP * LEAP(1:DIM)
%
% >> of the original low discrepancy Halton sequence.
%
% >> Author: John Burkardt
% >> Modified: 21 September 2004
% >> Licensing: this code is distributed under the GNU LGPL license.
%
% >> Reference(s):
%
% >> J. H. Halton,
% >> On the efficiency of certain quasi-random sequences of points in
% >> evaluating multi-dimensional integrals,
% >> Numerische Mathematik,
% >> Volume 2, 1960, pages 84-90.
%
% >> J. H. Halton and G. B. Smith,
% >> Algorithm 247: Radical-Inverse Quasi-Random Point Sequence,
% >> Communications of the ACM,
% >> Volume 7, 1964, pages 701-702.
%
% >> Ladislav Kocis and William Whiten,
% >> Computational Investigations of Low-Discrepancy Sequences,
% >> ACM Transactions on Mathematical Software,
% >> Volume 23, Number 2, 1997, pages 266-294.
%
% >> Input(s):
%
% >> Integer DIM, the spatial dimension: 1 <= DIM is required.
% >> Integer STEP, index of the subsequence element. 0 <= STEP is required.
% >> Integer SEED(DIM), Halton sequence index corresponding to STEP = 0.
% >> 0 <= SEED(1:DIM) is required.
% >> Integer LEAP(DIM), the successive jumps in the Halton sequence.
% >> 1 <= LEAP(1:DIM) is required.
% >> Integer BASE(DIM), the Halton bases. 1 < BASE(1:DIM) is required.
%
% >> Output(s):
%
% >> Real X(DIM), the STEP-th element of the leaped Halton subsequence.

dim           = floor(dim);
step          = floor(step);
seed(1:dim)   = floor(seed(1:dim));
leap(1:dim)   = floor(leap(1:dim));
base(1:dim)   = floor(base(1:dim));

% Data computation
seed2(1:dim) = seed(1:dim) + step*leap(1:dim);
% Output vector <x> preallocation
x(1:dim) = 0.0;
% Inverse basis <invBase>
invBase(1:dim) = 1.0./base(1:dim);
% MATLAB 'while' loop on <seed2>
while any(seed2(1:dim)~=0)
   digit(1:dim)   = mod(seed2(1:dim), base(1:dim));
   x(1:dim)       = x(1:dim) + digit(1:dim).*invBase(1:dim);
   invBase(1:dim) = invBase(1:dim)./base(1:dim);
   seed2(1:dim)   = floor(seed2(1:dim)./base(1:dim));
end

end